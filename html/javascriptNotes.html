<!doctype html>
<html lang="en">

<head>
    <title>JavaScript Notes</title>
    <link rel="stylesheet" href="/css/index.css">
    <link rel="stylesheet" href="/css/notes.css">

    <link href="https://fonts.googleapis.com/css2?family=Cormorant:ital,wght@0,300..700;1,300..700&family=Inter:wght@100..900&family=Just+Another+Hand&family=Kalam:wght@300;400;700&family=Karla:ital,wght@0,200..800;1,200..800&family=Orbitron:wght@400..900&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&family=Thasadith:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

    <!-- <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script> -->
</head>

<body data-id="javascript">
    <header>
        <div class="hero" id="hero">
            <h1><a href="../index.html">Coding Notes</a></h1>
            <h2>JavaScript</h2>
            <h3>By Rae</h3>
            <nav class="main-nav-bar">
                <ul id="navMenu" class="nav-menu">
                    <!-- rendered in js -->
                </ul>
                <div id="mobileMenu" class="mobile-menu"><li class="fa-solid fa-bars"></i></div>
            </nav>
        </div>
    </header>
    <main>
        <div class="head-sticky-note">
            <div class="sticky-note-content">
                <h2>JavaScript</h2>
                <ul>
                    <li>Conditionals</li>
                    <li>Loops</li>
                    <li>Functions</li>
                    <li>Fetch</li>
                </ul>
            </div>
        </div>
        <div class="page">
            <div class="full-head">
                <div class="page-head">
                    <div class="search-bar">
                        <div class="pencil-point"></div>
                        <input id="notesSearchInput" aria-label="Search Notes" placeholder="Search All JavaScript Notes" autoComplete="on" class="search-input" />
                        <button class="btn search-btn" id="notesSearchButton">Search</button>
                    </div>
                    <nav class="nav">
                        <ul id="sectionLinks">
                            <li data-link="notes">Notes</li>
                            <li data-link="resources">Resources</li>
                            <li data-link="definitions">Definitions</li>
                            <li data-link="questions">Questions</li>
                            <li data-link="opinions">Opinions</li>
                        </ul>
                    </nav>
                </div>
            </div>
            <div class="content" id="allNotes">
                <section id="javascript-section">
                    <div class="note-section notes" id="notes">
                        <h3 class="accordion-name" data-label="accordionName">Notes<span class="accordion-arrow first-arrow"></span></h3>
                        <ul class="inner-accordion-content" style="display: block;">
                            <li>Script tags in HTML are where you can write JS. add <blockcode>src="filename"</blockcode> to link js file to HTML file.</li>
                            <li><blockcode>console.log()</blockcode> to log to console.</li>
                            <li>JS reads top to bottom. Can't access things before they're initialized.</li>
                            <li>To create a function <blockcode>function functionName() {}</blockcode></li>
                            <li>Function is command.</li>
                            <li>Run is call or invoke.</li>
                            <li><blockcode>innerText</blockcode> gets/sets the text inside the element called. Can't read spaces.</li>
                            <li><blockcode>textContent</blockcode> gets/sets the text inside the element called. It can read spaces.</li>
                            <li>When it's a string VS a number the string always wins.</li>
                            <li>You can use an escape character (/) to display a " in a string surounded by "".</li>
                            <li>Name elements you grab <blockcode>elementPurposeEl</blockcode>.</li>
                            <li><blockcode>let</blockcode> creates the element, it can and will be changed later.</li>
                            <li><blockcode>const</blockcode> creates the element, it can't be changed later.</li>
                            <li>use `` when you need to add variables to text.</li>
                            <li>You can't use the same name for functions as in an element.</li>
                            <li class="sub-list"><span>Event Listeners</span>
                                <ul>
                                    <li><blockcode>container.addEventListener('listenerOfChoice', function{})</blockcode></li>
                                    <li>Using onclick in HTML is less ideal then using the event listener.</li>
                                    <li>click</li>
                                    <li>dblclick</li>
                                    <li>change</li>
                                    <li><a href="https://www.w3schools.com/jsref/dom_obj_event.asp" target="_blank" alt="List of all the possible events">Events I have never used.</a></li>
                                </ul>
                            </li>
                            <li>Operator precedence is PEMDAS in JS.</li>
                            <li><blockcode>++</blockcode> is self plus one.</li>
                            <li><blockcode>+=</blockcode> is self plus the oposite of the equal sign.</li>
                            <li><blockcode>===</blockcode> means strictly equal</li>
                            <li><blockcode>==</blockcode> is less strict. It converts numbers into strings if necessary.</li>
                            <li><blockcode>=</blockcode> means it will become.</li>
                            <li>An empty string <blockcode>""</blockcode> is a falsey value.</li>
                            <li>Expressions passed into conditions are translated into booleans. <blockcode>
                                if (const === 5){
                                    //runs if const === 5 (truthy)
                                    //ignores if const !==5 (falsey)
                                }
                            </blockcode></li>
                            <li class="sub-list"><span>Arrays</span>
                                <ul>
                                    <li>Arrays are stored in [].</li>
                                    <li>They start at 0.</li>
                                    <li>To call an array item do <blockcode>arrayName[0 (for first item), 1, 2, 3, -1 (for last item)]</blockcode>.</li>
                                    <li><blockcode>arrayName.length</blockcode> counts the number of items in an array, starting at one, which is why in a <blockcode>for (let i = 0; i &lt; array.length; i++){}</blockcode> 
                                        i is less than not less then or equal to.</li>
                                    <li>An array is a complex data type.</li>
                                    <li><blockcode>arrayName.push(newItem)</blockcode> adds content to the end of an array.</li>
                                    <li><blockcode>arrayName.pop()</blockcode> removes the last item of an array.</li>
                                </ul>
                            </li>
                            <li>The i for loop, <blockcode>for (let i = 0; i &lt; maxAmountOfLoop; i++){}</blockcode> will iterate through an array and represent each item as i. To get
                            i of the array, use <blockcode>arrayName[i]</blockcode></li>
                            <li>If you need a element from function1 use a parameter in function2 and call function2 in function1. <blockcode>
                                function function1(){
                                    const var1 = 'string';
                                    function2(var1);
                                }
                                function function2(var){
                                    var
                                }
                            </blockcode></li>
                            <li class="sub-list"><span>Object</span>
                                <ul>
                                    <li><blockcode>let objectName = { "key": "value" }</blockcode></li>
                                    <li>Turn an objects values into an array by using <blockcode>Object.values(objectName)</blockcode>.</li>
                                    <li>Turn an objects keys into an array by using <blockcode>Object.keys(objectName)</blockcode></li>
                                    <li>Turn an object into an array of arrays by using <blockcode>Object.entries(objectName)</blockcode></li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>Grabbing Elements</span>
                                <ul>
                                        <li><blockcode>.append(element)</blockcode> adds the string or object to whatever you're appending to.</li>
                                        <li><blockcode>getElementbyID('id')</blockcode> will get a single element with the unique id you provided. If more than one element has that id (id's should be unique) it will get the 
                                            first it finds.</li>
                                        <li>The <blockcode>querySelector('#id')</blockcode> is more dynamic. You have to be more specific and identify the element how you would in CSS 
                                            (with . or # before the name if applicable). It will return the first item with the parameter you entered. This is unique because it can grab psudo selectors.
                                        </li>
                                        <li><blockcode>getElementsbyClassName('class')</blockcode> will return an object-like array of all the child elements that have that class name.</li>
                                </ul>
                            </li>

                            <li class="sub-list"><span>The Dialog Tag</span>
                                <ul>
                                    <li><blockcode>dialog.show()</blockcode> opens a non-modal dialog.</li>
                                    <li><blockcode>dialog.showModal()</blockcode> opens a modal.</li>
                                    <li><blockcode>dialog.close()</blockcode> closes the dialog.</li>
                                    <li>To close the dialog when clicking outside the dialog box:
                                        <blockcode>
                                            dialog.addEventListener("click", e=> {
                                                const dialogDimentions = dialog.getBoundingClientRect()
                                                if (
                                                    // clicking outside the dialog
                                                    clientX &lt; dialogDimensions.left ||
                                                    e.clientX > dialogDimensions.right ||
                                                    e.clientY &lt; dialogDimensions.top ||
                                                    e.clientY > dialogDimensions.bottom ||
                                                    // clicking the cancel button
                                                    e.target.id === "cancel-dialog-btn"
                                                ){
                                                    dialog.close()
                                                }
                                            })
                                        </blockcode>
                                    </li>
                                </ul>
                            </li>
                            <li class="sub-list"><span><blockcode>setTimeout()</blockcode></span>
                                <ul>
                                    <li>A method that delays the execution of the code inside it for the entered time.</li>
                                    <li>
                                        <blockcode>
                                            setTimeout(function(){
                                                what you don't want to fire
                                            }, number of miliseconds you want to delay by)
                                        </blockcode>
                                    </li>
                                    <li><blockcode>
                                        setTimeout(functionName, 3000, 'functionParameter', 'second parameter')
                                    </blockcode></li>
                                    <li>To stop a timeout before it runs it's code you can use <blockcode>
                                        const timer = setTimeout(functionName, 3000, 'param')
                                        document.getElementById('stopBtn').addEventListener('click', function(){
                                            clearTimeout(timer)
                                        })
                                    </blockcode></li>
                                </ul>
                            </li>

                            <li class="sub-list"><span><blockcode>element.style</blockcode></span>
                                <ul>
                                    <li>Targets an element's style.</li>
                                    <li><blockcode>elementName.style.what you want to change = "what you want to change it to"</blockcode></li>
                                    <li><blockcode>elementName.style.display = 'none'</blockcode> to change the elements display to none, reguardless of entered CSS.</li>
                                </ul>
                            </li>
                            <li>To override the form information being pushed into the URL query screen,
                                <blockcode>
                                    formElement.addEventListener('submit', function(event){
                                        event.preventDefault();
                                    })
                                </blockcode>
                            </li>
                            <li>Any button in a form will submit by default. To stop this change the type. <blockcode>type="reset, submit, button"</blockcode> to anything but submit.</li>
                            <li class="sub-list"><span>Disabling Elements</span>
                                <ul>
                                    <li>Controlling when elements are usable.</li>
                                    <li>To disable on page load add <blockcode>disabled</blockcode> to HTML tag. <blockcode>
                                        &lt;button disabled&gt;
                                    </blockcode></li>
                                    <li>To disable after load, set disabled to true. <blockcode>
                                        document.getElementById('id').disabled = true
                                    </blockcode></li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>Class List</span>
                                <ul>
                                    <li><blockcode>element.classList.action('className')</blockcode> some actions are toggle, remove, and add.</li>
                                    <li>Just <blockcode>element.classList</blockcode> will return the entire class list of the element.</li>
                                    <li><blockcode>
                                            element.classList.toggle('className')
                                        </blockcode>
                                        switches the usage of the classlist back and forth.
                                    </li>
                                    <li><blockcode>
                                        element.classList.remove('className')
                                    </blockcode> will remove className from the elements class list.</li>
                                    <li><blockcode>
                                        element.classList.add('className')
                                    </blockcode>will add className to the elements class list.</li>                
                                </ul>
                            </li>
                            <li class="sub-list"><span>for of</span>
                                <ul>
                                    <li>A nicer way of iterating.</li>
                                    <il><blockcode>for (let item of itemsObjArr) {
                                            console.log(itemsObjArr[item])
                                        }
                                    </blockcode></il>
                                    <li>Iterates over object data structures.</li>
                                    <li>Iterates over the values of an iterable object. (examples of iterable objects include arrays, strings).</li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>for in</span>
                                <ul>
                                    <li><blockcode>for (let item in items){
                                        console.log(items[item])
                                    }</blockcode></li>
                                    <li>Iterates over object data structures.</li>
                                    <li>iterates over all enumerable property keys of an object.</li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>The Includes Method</span>
                                <ul>
                                    <li>A method for checking if an array holds a given value.</li>
                                    <li>An easy method for beginners.</li>
                                    <li>Returns a boolean.</li>
                                    <li><blockcode>arr.includes(value)</blockcode> would return true or false.</li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>Get the event in an event listener</span>
                                <ul>
                                    <li><blockcode>
                                        container.addEventListener('click', function(event){
                                            console.log(event.target)
                                        })
                                    </blockcode> will log the event target, which is the entire tag.</li>
                                    <li>If you log just event, you will see PointerEvent{ isTrusted: boolean } as the log.</li>
                                    <li>The target will show the most exact location it can (p.className#idName).</li>
                                    <li>An empty area in the container will return a string.</li>
                                    <li><blockcode>event.target.id</blockcode> would return just the id of what was clicked.</li>
                                    <li>Adding <blockcode>.parentElement</blockcode> to the end of what your selecting <blockcode>(event.target.id).parentElement</blockcode>
                                        will return the parent element of the element that had an event. So if this is the HTML
                                        <blockcode>
                                            &lt;div class="parent-element"&gt;
                                                &lt;div id="childElement"&gt;&lt;/div&gt;
                                            &lt;/div&gt;
                                        </blockcode>, then in the JS this
                                        <blockcode>event.target.id.parentElement</blockcode>, if the child element is selected, it would return <blockcode>&lt;div class="parent-element"&gt;</blockcode>.
                                    </li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>Writing Big Numbers in JS</span>
                                <ul>
                                    <li>You can add a numeric seperator, <blockcode>_</blockcode>, between numbers in the code to make it more readable and it will display without it. <blockcode>
                                        const longNumber = 9_007_199_254_740_991
                                        console.log(longNumber)//returns 9007199254740991
                                        console.log(typeof longNumber)//returns number
                                    </blockcode></li>
                                    <li>9007199254740991 is the highest number js can calculate without losing precision.</li>
                                    <li>For numbers bigger than 9007199254740991 you can use <blockcode>BigInt()</blockcode>. <blockcode>
                                        const longerNumber = 9007199254740991345n
                                        console.log(typeof longerNumber) // returns bigint, not number
                                    </blockcode>.</li>
                                    <li><blockcode>BigInt()</blockcode> is a constructor.</li>
                                    <li><blockcode>
                                        const longerNumber = BigInt(9_007_199_254_740_991_345)
                                        console.log(typeof longerNumber) // returns bigint
                                        console.log(longerNumber) // returns 9007199254740990976
                                        </blockcode>. They cannot Math, you cannot convert a BigInt value to a number. It is useful in contexts requiring precise handling of large integers, such as cryptography, 
                                        or when interacting with databases that use large integer identifiers.
                                    </li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>Parent Element</span>
                                <ul>
                                    <li><blockcode>.parentElement</blockcode></li>
                                    <li>Add to the end of an element to find its parent element.</li>
                                    <li><blockcode>
                                        childElement.parentElement
                                    </blockcode> would return the parent element of the selected child element.</li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>Console Log Static Method</span>
                                <ul>
                                    <li><blockcode>console.log()</blockcode></li>
                                    <li>You can pass in parameters. <blockcode>console.log(param1, param2)</blockcode></li>
                                    <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/console/log_static" target="_blank" alt="MDN Docs on the console log static method.">
                                        Check the Console Log Static Method MDN Doc
                                    </a></li>
                                </ul>
                            </li>
                            <li>To get wether or not a checkbox/radio was checked, get the element and add <blockcode>.checked</blockcode>, <blockcode>element.checked</blockcode> will return a boolean.
                                <blockcode>const isChecked = document.querySelector('input[type="radio"]:checked').value</blockcode> will grab the radio element if it is checked.
                            </li>
                            <li class="sub-list"><span>The Filter Method</span>
                                <ul>
                                    <li><blockcode>oldArray.filter(function(arrayItemName){return true})</blockcode></li>
                                    <li>Getting only the elements we want from an array.</li>
                                    <li>Creates a new array.</li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>The <blockcode>foreach()</blockcode> Method</span>
                                <ul>
                                    <li>A method for iterating over arrays.</li>
                                    <li><blockcode>
                                        arrayName.foreach(function(arrayItemName, index) {})
                                    </blockcode></li>
                                    <li>Does not return a new array.</li>
                                    <li>Use <blockcode>.forEach()</blockcode> if you don't need to create a new array.</li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>Data Attributes</span>
                                <ul>
                                    <li>Sorting Extra Information in HTML Elements.</li>
                                    <li>Often written in documents as data-*, the star representing the name you choose.</li>
                                    <li><blockcode>data-unique-name = "data"</blockcode></li>
                                    <li>To call it in js, as an event, it will be under target, in dataset, so it would be <blockcode>event.target.dataset.dataAttributeName(without data)</blockcode>.</li>
                                    <li>Great way to relate items to an id, without re-using an id.</li>
                                    <li>Does not have to be unique.</li>
                                    <li>If you use capital letters when assinging the data attribute, make them lowercase in js. It is best to just avoid uppercase letters.</li>
                                    <li>If you use cabob-case when asigning the data attribute, you will need to make it camalCase in js. This is the best practice for multi-word attributes.</li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>Copying Objects and Arrays</span>
                                <ul>
                                    <li>When you copy them in JS you are making a shallow copy.</li>
                                    <li>To make a real copy, you make a <a href="https://developer.mozilla.org/en-US/docs/Glossary/Deep_copy" target="_blank" alt="MDN Web Documentation on deep copy">deep copy</a>.</li>
                                </ul>
                            </li>
                            <li>To switch the value of a boolean (false to true, true to false) write <blockcode>boolean = !boolean</blockcode></li>
                            <li>Using <blockcode>else if</blockcode> instead of another <blockcode>if</blockcode>, will prevent the system from reading unused code if it was already true in the first if.</li>
                            <li class="sub-list"><span>Conditionally Render CSS</span>
                                <ul>
                                    <li>Giving elements different classes under different conditions.</li>
                                    <li><blockcode>
                                        let boolean = false;
                                        thingToClick.addEventListener('click', function(element){
                                            boolean = !boolean;
                                            if(boolean){
                                                booleanClass = 'className';
                                            };
                                            let booleanHTML = &lt;div class="${booleanClass}">&gt;&lt;/div&gt;
                                        });
                                    </blockcode></li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>UUID</span>
                                <ul>
                                    <li>Universally Unique Identifiers</li>
                                    <li>A string of 36 characters.</li>
                                    <li>Often used to identify pieces of data.</li>
                                    <li>Highly likely to be globally unique.</li>
                                    <li>Also known as GUID, or Globally Unique Identifier.</li>
                                    <li class="sub-sub-list"><span>You can have a UUID created with a CDN</span>
                                        <ul>
                                            <li>One of the most popular tools for generating UUIDS is <a href="https://github.com/uuidjs/uuid#cdn-builds"
                                            target="_blank" alt="UUID CDN builds Github documentation">UUID JS</a>. To copy this, go to the readme, select 
                                            the CDN Builds link, copy the import, paste it in your project (test it). Make sure your html has <blockcode>
                                            type="module"</blockcode> in the script tag. Return the uuidv4 function (you can rename that) as a function 
                                            <blockcode>uuidv4()</blockcode></li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li><blockcode>arrayName.unshift(element)</blockcode> adds the element to the beginning of the array.</li>
                            <li class="sub-list"><span>Object Destructuring</span>
                                <ul>
                                    <li>Extract properties from objects.</li>
                                    <li>It enables us to extract properties from objects into distinct variables.</li>
                                    <li>Helps keep your code DRY.</li>
                                    <li><blockcode>
                                        const {propertyVariableName, propertyVariableName2, propertyVariableName3} = objectName
                                        console.log(`display this ${propertyVariableName}'s value`)
                                    </blockcode></li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>The <blockcode>.map()</blockcode> Method</span>
                                <ul>
                                    <li>Iterating over arrays.</li>
                                    <li><blockcode>
                                        const newArray = oldArray.map(function(nameValues, index) {
                                            //iterates through each array value
                                            //index will return the index of each value
                                        })
                                    </blockcode></li>
                                    <li>could be stored in a function instead of a const.</li>
                                    <li>Use <blockcode>.map()</blockcode> if you need to make use of the new array it returns</li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>The .join() Method</span>
                                <ul>
                                    <li>Strings from arrays.</li>
                                    <li>Concatenates elements of an array into a string.</li>
                                    <li>You choose how elements are separated.</li>
                                    <li>It returns the new string.</li>
                                    <li><blockcode>
                                        console.log(arrayName.join('what you want between each value'))
                                    </blockcode></li>
                                    <li>To have no seperator just keep an empty string, there will be no space between them though.</li>
                                </ul>
                            </li>
                            <li>All methods must end with parenthesis.</li>
                            <li>To find out what type an element is put typeof before it. It will return if it's a string, boolean, ect. <blockcode>
                                console.log(typeof booleanEl)
                            </blockcode> would return boolean.</li>
                            <li>You can only chain onto a method if it returns an array.</li>
                            <li class="sub-list"><span>The For Loop</span>
                                <ul>
                                    <li><blockcode>break</blockcode> and <blockcode>continue</blockcode> can be use within for loops.</li>
                                    <li><blockcode>for (let i = 0; i &lt arr.length; i++){}</blockcode> is a common for loop.</li>
                                    <li><blockcode>for (let i = 0; i &lt arr.length; i++){
                                        if (arr.key &lt 5){break}
                                        if (arr.key &gt 5 {continue}
                                        console.log('this will not run if the arr.key is greater than or less than five'))
                                    } </blockcode></li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>Various Array Methods</span>
                                <ul>
                                    <li><blockcode>arr.every(function(arrItem){
                                        return arrItem >= 30
                                    })</blockcode> Every array item will be subject to the code within the function, and you will get a boolean true or false response. It will only return true if every item is true.</li>
                                    <li><blockcode>.some(function(arrItem){
                                        return arrItem >= 30
                                    })</blockcode> Every array item will be subject to the code within the funciton, and you will get a boolean true or false response. It will return true if one or more items are true.</li>
                                    <li><blockcode>arr.find(function(arrItem){
                                        return arrItem > 30
                                    })</blockcode> Every array item will be subject to the code within the function until one is true, you will get the items content as a response. If none are true, then it will 
                                        return undefined.
                                    </li>
                                    <li><blockcode>.findIndex(function(arrItem){
                                        return arrItem > 30
                                    })</blockcode> Every array item will be subject to the code within the function until one is true, you will get the items index number as a response. If no item is true, it will return -1.</li>
                                    <li><blockcode>arr.indexOf(arrItemContent)</blockcode> Every array item will be tested for the content until one is found with it, then it will return that items index number.</li>
                                    <li><blockcode>arr.at(-1)</blockcode> Takes a positive or negative integer and returns the item at that index. Negative integers will count back from the end of the array.</li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>Replace Method</span>
                                <ul>
                                    <li><blockcode>text.replace(pattern, replacement)</blockcode></li>
                                    <li><blockcode>const text = "hello how are you?"
                                        text.replace('h', 'H')
                                    </blockcode> will return 'Hello how are you', changing the first h but not the second.</li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>ReplaceAll Method</span>
                                <ul>
                                    <li><blockcode>text.replaceAll(pattern, replacement)</blockcode></li>
                                    <li><blockcode>const text = "hello! how are you this morning?"
                                        text.replaceAll('h', 'H')
                                    </blockcode> will return 'Hello! How are you tHis morning', changing the all h to H.</li>
                                    <li>To avoid the above problem of capitalizing letters within words you can use regex (regular expression). This is a sequence of characters that specifies a match pattern in text.
                                        <blockcode>/[a-zA-Z1-9]/</blockcode> will find any number 1-9 and any letter, lower or uppercasea-z.
                                        <blockcode>/^\d{5} (-\d{4})?$/</blockcode> will validate US zip codes.
                                        In this case you would do text.replaceAll(/\b(h)\b/g, 'H')
                                    </li>
                                    <li>You can also use functions in the replaceAll.
                                        <blockcode>
                                            const text = "I love you with all my heart!"
                                            console.log(text.replaceAll(/\b(love|heart)\b/g, function(match){
                                                return `${match} &lt3`
                                            }))
                                        </blockcode> will log "I love &lt3 you with all my heart &lt3".
                                    </li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>RegExp</span>
                                <ul>
                                    <li>\d = any number between 1 and 9</li>
                                    <li>. = any single character</li>
                                    <li>[abc] = will match a, b or c</li>
                                    <li>[^abc] = all but a, b or c</li>
                                    <li>[0-6] = will match any single 0, 1, 2, 3, 4, 5 or 6</li>
                                    <li>[^a-p] = will match q through z</li>
                                    <li>\w = includes any single alphanumeric character plus the underscore</li>
                                    <li>[a-z] is different then [A-Z]</li>
                                    <li>a{3} = aaa</li>
                                    <li>[wxy]{5} = any sequence with exactly 5 characters that are either w, x or y</li>
                                    <li>.{2,6} = matches any sequence that is between 2 and 6 characters long</li>
                                    <li>\d = any single digit between 0 and 9</li>
                                    <li>a* = 0 or more of a</li>
                                    <li>ab?c = abc or ac (b is optional)</li>
                                    <li>_ = a space</li>
                                    <li>\t = tab</li>
                                    <li>\n = new line</li>
                                    <li>\r = return</li>
                                    <li>\s = any white space</li>
                                    <li>\S = no white space</li>
                                    <li>g = g flag = global = looking for all instances, not just one. Needed if you are using replace all after the ending /</li>
                                    <li>i = i falg = case insensitive = </li>
                                    <li>regexp has a test method that returns a boolean. <blockcode>
                                        regex.test(text)
                                    </blockcode></li>
                                    <li>There is a RegExp Constructor. <blockcode>
                                        const textText = "hello world"
                                        const regex = new RegExp(testText, 'gi')
                                    </blockcode></li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>hasOwn/hasOwnProperty</span>
                                <ul>
                                    <li>hasOwn is more modern.</li>
                                    <li><blockcode>Object.hasOwn(objectName, 'propertyName')</blockcode>, static method,</li>
                                    <li><blockcode>objectName.hasOwnProperty('propertyName')</blockcode></li>
                                    <li>Tells you weather the property is on the object.</li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>Value/Reference</span>
                                <ul>
                                    <li>Primitives, strings, numbers and booleans are passed by value.</li>
                                    <li>Objects and arrays are passed by reference.</li>
                                    <li>There are two ways to copy arrays, Deep Copy and Shallow Copy.</li>
                                    <li>Shallow Copy creates a new object or array but only at the first level. For nested objects or arrays, a shallow copy Will
                                        still hold references to the original nested objects or arrays.
                                    </li>
                                    <li>Deep copy copies the entire array or object.</li>
                                </ul>
                            </li>
                            <li class="sub-list">
                                <ul>
                                    <li>To one element with a given id use <blockcode>getElementByid('idName')</blockcode>.</li>
                                    <li>To grab all elements with a given class use <blockcode>getElementsByClassName('className')</blockcode>.</li>
                                </ul>
                            </li>
                            <li>You can usually get rid of an <blockcode>else</blockcode> if you are returning in the <blockcode>if</blockcode>.</li>
                            <li class="sub-list"><span>Function Expressions</span>
                                <ul>
                                    <li>Different Syntax and Behavior.</li>
                                    <li>Are not hoisted (cleaner).</li>
                                    <li><blockcode>
                                        const name = function(parameter){}
                                    </blockcode></li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>Arrow Functions</span>
                                <ul>
                                    <li>Ultra Consise functions.</li>
                                    <li>One parameter: <blockcode>
                                        const name = parameter => { return stuff }
                                    </blockcode> or <blockcode>
                                        const name = (parameter) => { return stuff }
                                    </blockcode></li>
                                    <li>No parameter: <blockcode>
                                        const name = () => {}
                                    </blockcode></li>
                                    <li>Multiple parameters: <blockcode>
                                        const name = (parameter1, parameter2) => { return stuff}
                                    </blockcode></li>
                                    <li>You have to add the curly braces and return keyword when there's more complex logic, but when it's one simple line of code you don't need the curly braces and return keyword.</li>
                                    <li>If you don't return anything it is undefined.</li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>Import and Export</span>
                                <ul>
                                    <li class="sub-sub-list"><span>Name Export</span>
                                        <ul>
                                            <li>To rename what you're importing ad an as <blockcode>
                                                import { oldName as newName } from 'fileLocation'
                                            </blockcode></li>
                                            <li>To import multiple things from one file, use a comma <blockcode>
                                                import { oneThing, secondThing } from 'fileLocation'
                                            </blockcode> You must export them both, but if you do you have to name every name export that is passed in that import.</li>
                                            <li>To export multiple exports <blockcode>export { exportNameOne, exportName2}</blockcode> or <blockcode>export function(){}</blockcode> exports the function.
                                            </li>
                
                                        </ul>
                                    </li>
                                    <li class="sub-sub-list"><span>Default Export</span>
                                        <ul>
                                            <li><blockcode>
                                                export default function(param1, param2){
                                                    //code stuff
                                                }
                                            </blockcode></li>
                                            <li>Gives you the advantage of calling this function whatever you want. Renaming the function can cause
                                                confustion and make code less readable. <blockcode>
                                                import nameYouWant from './fileLocation.js'
                                            </blockcode></li>
                                            <li>You can only have one default export from a file.</li>
                                        </ul>
                                    </li>
                                    <li>Anytime you use the import or export in JS you have to add <blockcode>type="module"</blockcode> to the HTML JS file reference.</li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>The <blockcode>.reduce()</blockcode> Method</span>
                                <ul>
                                    <li>Returns only one thing from an array.</li>
                                    <li>Takes in a function.</li>
                                    <li>Iterates through the array given the parameters till it has combined all values. <blockcode>
                                        arrayName.reduce(function(total, currentElementb ){})
                                    </blockcode></li>
                                    <li>Must use return keyword.</li>
                                    <li>To get a value of an array</li>
                                    <li>Written as arrow function <blockcode>
                                        const totalOfArray = arrayName.reduce(
                                            (param1, param2) => param1 + param2,
                                        );
                                    </blockcode></li>
                                    <li>When using objects and returning numbers with a reduce method <blockcode>
                                        const total = array.reduce(function(total, currentElementb){
                                            return total + currentElementb.numbersKey
                                        }, 0)
                                    </blockcode> The 0 will set the default start of the total to be 0, instead of an object.</li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>Default Parameters</span>
                                <ul>
                                    <li>Protection against bugs.</li>
                                    <li><blockcode>
                                        function functionName(arrayName, secondParam = defaultValue){}
                                    </blockcode></li>
                                    <li>The defulat will only be used when you don't pass in an argument when calling the function.</li>
                                    
                                </ul>
                            </li>
                            <li class="sub-list"><span>The Ternary Operator</span>
                                <ul>
                                    <li>An alternative to if/else (sometimes).</li>
                                    <li><blockcode>condition(true or false value) ? expression(executes if true) : expression(executes if false)</blockcode></li>
                                    <li><blockcode>condition ? ifTrue : condition ? ifTrue : else</blockcode></li>
                                    <li>Complex login is not easy to read with a ternary operator.</li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>The Rest Parameter</span>
                                <ul>
                                    <li>Catching the rest of the arguments.</li>
                                    <li><blockcode>
                                        function functionName(parameter, ...restParameterName){
                                            //iterates through restParameterName as many times as there are parameters for it.
                                        }
                                        functionName('param1', 'param2', 'param3', 'param4', 'param5',)
                                        //Would go through function for all entered params 1-5
                                    </blockcode></li>
                                    <li>Taking in the REST of the arguments (get it).</li>
                                    <li>The rest parameter must go last.</li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>The Spread Operator</span>
                                <ul>
                                    <li>Expanding and joining arrays.</li>
                                    <li><blockcode>
                                        const arrayOne = ['arrayStuff1', 'arrayStuff2', 'arrayStuff3']

                                        console.log(...arrayOne)
                                        //logs arrayStuff1 arrayStuff2 arrayStuff3
                                    </blockcode></li>
                                    <li>Really good way of making a copy of an array <blockcode>
                                        const arrayOne = ['arrayStuff1', 'arrayStuff2', 'arrayStuff3']
                                        const arrayOneCopy = [...arrayOne]

                                        console.log(arrayOneCopy)
                                        //logs ['arrayStuff1', 'arrayStuff2', 'arrayStuff3']
                                    </blockcode></li>
                                    <li>Useful for combining arrays in a new array <blockcode>
                                        const arrayOne = ['arrayStuff1', 'arrayStuff2', 'arrayStuff3']
                                        const arrayTwo = ['array2Stuff1', 'array2Stuff2', 'array2Stuff3']
                                        const arrayThree = ['array3Stuff1', 'array3Stuff2', 'array3Stuff3']

                                        const combinedArrays = [...arrayOne, ...arrayTwo, ...arrayThree]

                                        console.log(combinedArrays)
                                        //logs ['arrayStuff1', 'arrayStuff2', 'arrayStuff3', 'array2Stuff1', 'array2Stuff2', 'array2Stuff3', 'array3Stuff1', 'array3Stuff2', 'array3Stuff3']
                                    </blockcode></li>
                                    <li>Shallow Copy</li>
                                </ul>
                            </li>
                            <li>To find the highest number of a list of numbers use <blockcode>Math.max(numberlist)</blockcode>.</li>
                            <li>To find the loweset number of a list of numbers use <blockcode>Math.min(numberlist)</blockcode>.</li>
                            <li class="sub-list"><span>Short-Circuit</span>
                                <ul>
                                    <li>More concise code for conditional logic.</li>
                                    <li>The logical OR operator <blockcode>||</blockcode>. Evaluates from left to right and stops evaulating once it finds something truthy. <blockcode>
                                        const arrayName = {
                                            key1: 'value1'
                                            //key2: 'value2'
                                        }
                                        const variable = array.key2 || 'That key does not exist'
                                        console.log(variable)
                                        //logs 'That key does not exist'
                                    </blockcode></li>
                                    <li>The logical AND operator <blockcode>&&</blockcode>. Evaluates from left to right and if the stuff on the left is true, executes the stuff on the right <blockcode>
                                        const exampleArray = {
                                            key1: 'value1'
                                        }
                                        exampleArray.key1 === 'value1' && console.log('This is ran')
                                        //logs 'This is ran'
                                        exampleArray.key1 === 'value2' && console.log('This is not ran')
                                        //nothing is logged
                                    </blockcode></li>
                                    <li>Nullish Coalescing Operator, <blockcode>??</blockcode>, returns the right hand operator truthy value if the left hand operator is null or undefined.</li>
                                    <li>Optional Chaining, <blockcode>?.</blockcode>, adds optional additions to your chain. <blockcode>
                                        const library = {
                                            sections: {
                                                fantasy: [
                                                    {title: 'The Long Way to a Small, Angry Planet'}
                                                ]
                                            }
                                        }
                                        console.log(library?.sections?.fantasy[0]?.title)
                                    </blockcode> Would log 'The Long Way to a Small, Angry Planet'. If anything is wrong, it will log undefined, instead of throwing an error.</li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>Switch Statements</span>
                                <ul>
                                    <li>Select one of many code blocks to execute.</li>
                                    <li><blockcode>
                                        function functionName(parameter){
                                            switch(parameter){
                                                case 'parameter possiblity';
                                                    //the following code will only run if the case is correct
                                                    break //won't run the code below
                                                case 'another possibility':
                                                    //the following code will only run if the case is correct
                                                    break
                                                default:
                                                    //runs if none of the cases are true
                                            }
                                        }
                                    </blockcode></li>
                                    <li>The last item (default or case) does not need a break.</li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>Constructors</span>
                                <ul>
                                    <li>Constructors have two main categories, Inbuilt and Custom.</li>
                                    <li>Inbuilt Constructors provide objects in various predetermined formats, like Date Objects and Error Objects,
                                        and Objects for each data type.
                                    </li>
                                    <li>Custom Constructors are constructors we design ourselves to provide objects for our own specific purposes.</li>
                                    <li class="sub-sub-list"><span>The Date Constructor</span>
                                        <ul>
                                            <li>An inbuilt constructor.</li>
                                            <li>To use the Date() constructor <blockcode>
                                                const nameofThing = new Date()
                                                //returns an object
                                                //return example: 2024-06-27T22:42:07.898Z
                                                //To make it more readable put 
                                                nameofThing.toString()
                                                //return example: Thu Jun 27 2024 16:43:55 GMT-0600 (Mountain Daylight Time)
                                                //gives exact date and time of where you are
                                            </blockcode></li>
                                            <li>To return the current year use <blockcode>
                                                new Date().getFullYear()
                                            </blockcode></li>
                                            <li>luxon makes working with dates and times easier.</li>
                                        </ul>
                                    </li>
                                    <li class="sub-sub-list"><span>The Error Constructor</span>
                                        <ul>
                                            <li><blockcode>
                                                throw new Error('Your error here')
                                            </blockcode> The throw keyword will stop all the code after your throw from running.</li>
                                            <li>Code will continue running after your error<blockcode>
                                                console.log(new Error('Your error here'))
                                            </blockcode></li>
                                        </ul>
                                    </li>
                                    <li>The Object Constructor <blockcode>new Object()</blockcode> will create a new object. Much better to use the litteral <blockcode>{}</blockcode></li>
                                    <li><blockcode>String()</blockcode></li>
                                    <li><blockcode>Number()</blockcode></li>
                                    <li><blockcode>Array()</blockcode></li>
                                    <li><blockcode>Boolean()</blockcode></li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>The Error() Constructor</span>
                                <ul>
                                    <li><blockcode>
                                        throw new Error('error text')
                                    </blockcode></li>
                                    <li>throw will stop all following code from executing.</li>
                                </ul>
                            </li>
                            <li>Other Constructors are <blockcode>String() Number() Array() Object() Boolean()</blockcode> but they are rarely used.</li>
                            <li>You can add a function to within an object and access it. <blockcode>
                                const objectName = {key1: 'value1', key2: 'value2', key3: function(){}}
                                objectName.key3()
                            </blockcode></li>
                            <li><blockcode>this</blockcode> can be used within an object to refer to the object name instead of typing it out.
                            If you are using an arrow function within the object using <blockcode>this</blockcode> will refer to what's beyond the function (window).</li>
                            <li class="sub-list"><span>Classes</span>
                                <ul>
                                    <li>Templates for objects.</li>
                                    <li><blockcode>
                                        class NameofClass {
                                            constructor(param1, param2){
                                                this.param1 = param1
                                                this.param2 = param2
                                            }

                                            fuctionName() {
                                                
                                            }
                                        }
                                        const thingName = new NameofClass('param1', param2)
                                        thingName.functionName()
                                    </blockcode></li>
                                    <li>needs to be constructor. cannot be called anything else</li>
                                    <li>Biggest difference from Constructor is classes are not hoisted.</li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>Debugging</span>
                                <ul>
                                    <li class="sub-sub-list"><span>Suntax and Logic Errors</span>
                                        <ul>
                                            <li>SyntaxError: missing &rpar; after argument list means not enough &rpar;</li>
                                            <li>SyntaxError: Unexpected token '&rpar;' means not enough &rpar;s</li>
                                            <li>TypeError: varName.value.addEventListener is not a function means js is expected a value from a function, but can't find it.</li>
                                            <li>ReferenceError: VarName is not defined means you probably mispelled it, or it isn't define there.</li>
                                            <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors" target="_blank" alt="Learn more about JavaScript error references from MDN.">To learn more about errors</a></a></li>
                                        </ul>
                                    </li>
                                    
                                    <li>To intentionally throw an error <blockcode>
                                        function functionName(parameter){
                                            try {
                                                if (typeof parameter === 'number'){
                                                    console.log(parameter)
                                                } else {
                                                    throw new ReferenceError('Error Message')
                                                }
                                            } catch (err) {
                                                console.log('Error: ' + err)
                                            }
                                        }
                                        functionName('String')

                                        //logs "Error: ReferenceError: Error Message"
                                    </blockcode></li>

                                    <li class="sub-sub-list"><span>Helpful Debugging Tool</span>
                                        <ul>
                                            <li>In inspector (ctrl/cmnd + i), find Sourches, Breakpoints (Run code until a breakpoint, allowing you to see what happens up to that point. Great to execute code step by step until you find the problem.)
                                                , Watchers (Monitor the values of variables or expressions overtime as you step through your code. useful to see how and when a value changes during your code.).
                                            </li>
                                        </ul>
                                    </li>
                                    <li><a href="https://firefox-source-docs.mozilla.org/devtools-user/debugger/" target="_blank" alt="Firefox source docs on Javascript debugging">Go to this doc to learn more advanced debugging skills.</a></li>
                                </ul>
                            </li>
                            <li class="sub-list"><span><blockcode>setInterval()</blockcode></span>
                                <ul>
                                    <li>Makes code repeatedly execute and regular intervals.</li>
                                    <li><blockcode>
                                        const intervalTimer = setInterval(function(){
                                            //do code
                                            clearInterval(intervalTimer)
                                        }, 1000)
                                    </blockcode></li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>JS Runtime Environment (the V8 Engine)</span>
                                <ul>
                                    <li>The Heap - handles memory allocations so we don't have to.</li>
                                    <li>The Call Stack - where code executes - As js is single threaded, the call stack can only excecute one piece of code at a time in its single thread.</li>
                                    <li>Js is helped by WebAPIs, task queue, and event loop, all are not a part of the js language.</li>
                                    <li>JS can multi-task (<blockcode>.setTimeout()</blockcode>, <blockcode>.setInterval()</blockcode>, fetching data across the network, promises).</li>
                                    <li>The webAPI is what counts for timeouts and intervals. After the time is done it passes the code to the Task Queue, which will send the code at the top of the queue to the call stack once it is empty.</li>
                                    <li>If code is complex, the execution of setTimout and setInterval will take longer. It will never take the exact ms you put in, just slliiiiightly above it. Unoticable.</li>
                                </ul>
                            </li>
                            <li><blockcode>performance.now()</blockcode> is a really super accurate timestamp.</li>
                            <li>++Pre-increment, just move the increment opperator to the front of your expression.<blockcode>return ++count</blockcode>. The pre-increment operator increments the variable's value before the result of the increment is used in an expression.</li>
                            <li>--Pre-decrement, just move the decrement opperator to the front of your expression.<blockcode>return --loss</blockcode>. The pre-decrement operator decreases the variable's value before the result of the decrement is used in an expression.</li>
                            <li>Number Separators will separate out the digits into chunks</li>
                            <li class="sub-list"><span><blockcode>Object.assign()</blockcode></span>
                                <ul>
                                    <li>Makes a shadow copy of an object.</li>
                                    <li>Copies properties from a source object to a target object</li>
                                    <li>Returns the new version of the target object.</li>
                                    <li><blockcode>
                                        const source = {key: 'value', keyObj: {'value2', 'value2', 'value3'}}
                                        const target = {}
                                        Object.assign(target, source)
                                        source.keyObj[0] = 'value1'
                                        console.log(target)
                                    </blockcode> will log {key: 'value', keyObj: {'value1', 'value2', 'value3'}}.</li>
                                </ul>
                            </li>
                            <li class="sub-list"><span><blockcode>structuredClone()</blockcode></span>
                                <ul>
                                    <li>Makes a deep copy.</li>
                                    <li><blockcode>
                                    <li><blockcode>
                                        const source = {key: 'value', keyObj: {'value2', 'value2', 'value3'}}
                                        const target = structuredClone(source)
                                        source.keyObj[0] = 'value1'
                                        console.log(target)
                                    </blockcode> will log {key: 'value', keyObj: {'value2', 'value2', 'value3'}}.</li>
                                </ul>
                            </li>
                            <li class="sub-list"><span><blockcode>this</blockcode></span>
                                <ul>
                                    <li><blockcode>
                                        const obj = {
                                            key1: 'value1',
                                            key2: 'value2',
                                            key3: function(){
                                                console.log(this)
                                            }
                                            obj.key3()
                                        }
                                    </blockcode> will log {key1: 'value1', key2: 'value2', key3: ()}. If you use an arrow function it will log out "window" instead.</li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>The <blockcode>.bind()</blockcode> method</span>
                                <ul>
                                    <li><blockcode>
                                        const obj = {
                                            key1: 'value1',
                                            key2: 'value2',
                                            key3: function(){
                                                console.log(this)
                                            }
                                        }
                                        const objDetails = obj.key3.bind(obj)
                                    </blockcode> logs out {key1: 'value1', key2: 'value2', key3: ()}</li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>Creating Funcitons</span>
                                <ul>
                                    <li class="sub-sub-list"><span>Factory Functions</span>
                                        <ul>
                                            <li>A normal funciton that returns an object.</li>
                                            <li><blockcode>
                                                function functionName(param1, param2){
                                                    return {
                                                        param1: param1,
                                                        param2: param2,
                                                        anotherFunction(){
                                                            console.log(this)
                                                        }
                                                    }
                                                }
                                            </blockcode></li>
                                            <li>Object property value shorthand is used to write params only once. <blockcode>
                                                function functionName(param1, param2){
                                                    return {
                                                        param1,
                                                        param2
                                                    }
                                                }
                                            </blockcode></li>
                                            <li>Pros to factory functions: The syntax is familiar and easy to read.</li>
                                            <li>Cons to factory functions: Less performant, and No inheritance.</li>
                                        </ul>
                                    </li>
                                    <li class="sub-sub-list"><span>Constructor Functions</span>
                                        <ul>
                                            <li><blockcode>
                                                function Functionname(param1, param2){
                                                    this.param1 = param1
                                                    this.param2 = param2
                                                    this.anotherFunction = function() {
                                                        console.log(this)
                                                    }
                                                }</blockcode>
                                            </li>
                                            <li>You provide the properties and methods.</li>
                                            <li><blockcode>
                                                function Constructor(name1, name2){
                                                    this.name1 = name1
                                                    this.name2 = name2
                                                    this.function = function(){}
                                                }
                                                const newObj = new Constructor('name1', 'name2')
                                                newObj.function()
                                            </blockcode></li>
                                        </ul>
                                        <li class="sub-sub-list"><span>Form Data Constructor Function</span>
                                            <ul>
                                                <li><blockcode>FormData(formElement)</blockcode></li>
                                                <li>Returns all inputed data as an object.</li>
                                                <li>Is a constructor function.</li>
                                                <li><blockcode>const formElementData = new FormData(formElement)</blockcode></li>
                                                <li>To see what the object holds use <blockcode>formElementData.get(nameData)</blockcode></li>
                                            </ul>
                                        </li>
                                    </li>
                                    <li class="sub-sub-list"><span>Classes</span>
                                        <ul>
                                            <li>Templates for objects</li>
                                            <li><blockcode>
                                                class Classname {
                                                    constructor(param1, param2){
                                                        this.param1 = param1
                                                        this.param2 = param2
                                                    }
                                                    functionName(){
                                                        console.log(this.param1)
                                                    }
                                                }
                                                const instance = new Classname('param1', 'param2')
                                                instance.functionName()
                                            </blockcode></li>
                                            <li>Classes are not hoisted</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li class="sub-list"><span><blockcode>.call()</blockcode></span>
                                <ul>
                                    <li><blockcode>
                                        function functionName(param1) {
                                            console.log(`${this.key1} ${this.key2} ${param1}`)
                                        }
                                        
                                        const instance = {
                                            key1: 'value1',
                                            key2: 'value2'
                                        }
                                        
                                        functionName.call(instance, 'param1')
                                    </blockcode></li>
                                </ul>
                            </li>
                            <li class="sub-list"><span><blockcode>.apply()</blockcode></span>
                                <ul>
                                    <li>Takes an array of arguments</li>
                                    <li><blockcode>
                                        function functionName(param1) {
                                            console.log(`${this.key1} ${this.key2} ${param1}`)
                                        }
                                        
                                        const instance = {
                                            key1: 'value1',
                                            key2: 'value2'
                                        }
                                        
                                        functionName.apply(instance, ['param1'])
                                    </blockcode></li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>Inheritance</span>
                                <ul>
                                    <li>The Prototype Chain is the order in which things can be inherited by Objects. The top one inherits from Object.</li>
                                    <li>Polymorphism an object can override inheritance, adapting for specific needs. It allows methods to have different implementations 
                                        on different objects. An object can override a method it inherits, adapting it for specific needs.</li>
                                    <li><blockcode>
                                        const firstObj = {
                                            key1: '',
                                            key2: '',
                                            key3: '',
                                            key4: function(){}
                                        }
                                        const secondObj = {
                                            key5: ;;,
                                        }
                                    </blockcode></li>
                                    <li class="sub-sub-list"><span>Inheritance with constructor functions</span>
                                        <ul>
                                            <li>The call method is used to call a function with a specified 'this' value and arguments.</li>
                                            <li><blockcode>
                                                function Parentconstructor(param1, param2, param3){
                                                    this.param1 = param1
                                                    this.param2 = param2
                                                    this.param3 - param3
                                                    this.functionName = function(){
                                                        return `${param1}, ${param2}, ${param3}`
                                                    }
                                                }
                                                function Childconstructor(param1, param2, param3, param4){
                                                    Parentconstructor.call(this, param1, param2, param3)
                                                    this.param4 = param4
                                                }

                                                Childconstructor.prototype = Object.create(Parentconstructor.prototype)
                                                Childconstructor.prototype.constructor = Childconstructor
                                            </blockcode> prototype is by default a reference to the base Object or Object Object. </li>
                                        </ul>
                                    </li>
                                    <li class="sub-sub-list"><span>Overriding Inherited Methods on Constructor Functions</span>
                                        <ul>
                                            <li><blockcode>
                                                function Parentconstructor(param1, param2, param3){
                                                    this.param1 = param1
                                                    this.param2 = param2
                                                    this.param3 - param3
                                                    this.functionName = function(){
                                                        return `${param1}, ${param2}, ${param3}`
                                                    }
                                                }

                                                Parentconstructor.prototype.newFunctionName = function() {
                                                    return 'stuff'
                                                }

                                                function Childconstructor(param1, param2, param3, param4){
                                                    Parentconstructor.call(this, param1, param2, param3)
                                                    this.param4 = param4
                                                }

                                                Childconstructor.prototype = Object.create(Parentconstructor.prototype)
                                                Childconstructor.prototype.constructor = Childconstructor

                                                Childconstructor.prototype.newFunctionName = function() {
                                                    const varName = Parentconstructor.prototype.getDetails.call(this)
                                                }
                                            </blockcode> newFunctionName will be overridable.</li>
                                        </ul>
                                    </li>
                                    <li class="sub-sub-list"><span>Inheritance with Class Syntax</span>
                                        <ul>
                                            <li><blockcode>
                                                class Parentclass {
                                                    constructor(param1, param2, param3) {
                                                        this.param1 = param1
                                                        this.param2 = param2
                                                        this.param3 = param3
                                                    }
                                                
                                                    functionName() {
                                                        return `param1: ${this.param1}, param2: ${this.param2}, param3: ${this.param3}`
                                                    }
                                                }
                                                
                                                class Childclass extends Parentclass {
                                                    constructor(param1, param2, param3, param4) {
                                                        super(param1, param2, param3)
                                                        this.param4 = param4
                                                    }

                                                    functionName(){
                                                        const superName = super.functionName()
                                                        return `${superName} param4: ${param4}`
                                                    }
                                                }

                                                const class = new Childclass('param1', 'param2', 'param3', 'param4')
                                            </blockcode></li>
                                            <li>The 'super' keyword is used to do two things, access properties on the superclass's prototype and invoke the superclass's constructor.</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>Static Methods and Properties</span>
                                <ul>
                                    <li>Creating an object that is not available on the instances.</li>
                                    <li><blockcode>
                                        class ClassName {
                                            static staticName = 0
                                            constructor(param1) {
                                                this.param1 = param1
                                                ClassName.staticName++
                                            }
                                            
                                            static staticFunctionName() {
                                                return ClassName.staticName
                                            }
                                        }

                                        console.log(ClassName.staticFunctionName())                                        
                                    </blockcode></li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>Private Fields</span>
                                <ul>
                                    <li>Not properties of this in the same way public properties are.</li>
                                    <li><blockcode>
                                        class ClassName {
                                            #privateProperty
                                            constructor(privateProperty, param2){
                                                this.#privateProperty = privateProperty
                                                this.param2 = param2
                                            }
                                        }
                                        const variable = new ClassName('privateProperty', 'param2')
                                    </blockcode> variable would log out ClassName {param2: param2}</li>
                                    <li class="sub-sub-list"><span>Access Private field with getters and setters</span>
                                        <ul>
                                            <li>Getter: <blockcode>
                                                class ClassName {
                                                    #privateProperty
                                                    constructor(privateProperty, param2){
                                                        this.#privateProperty = privateProperty
                                                        this.param2 = param2
                                                    }

                                                    get privateProperty(){
                                                        return this.#privateProperty
                                                    }
                                                }
                                                const variable = new ClassName('privateProperty', 'param2')        
                                            </blockcode> logging variable.privateProperty will give you privateProperty</li>
                                            <li>Still can't be modified so access is controlled.</li>
                                            <li>Setter: <blockcode>
                                                class ClassName {
                                                    #privateProperty
                                                    constructor(privateProperty, param2){
                                                        this.#privateProperty = privateProperty
                                                        this.param2 = param2
                                                    }

                                                    get privateProperty(){
                                                        return this.#privateProperty
                                                    }

                                                    set privateProperty(newPrivateProperty){
                                                        if (typeof newPrivateProperty !== 'string' || newPrivateProperty.length &gt;= 0){
                                                            throw new Error('newPrivateProperty is not valid')
                                                        }
                                                        this.#privateProperty = newPrivateProperty
                                                    }
                                                }
                                                const variable = new ClassName('privateProperty', 'param2')
                                                variable.privateProperty = 'newPrivateProperty'
                                            </blockcode></li>
                                            <li>Can be modified.</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>Symbols</span>
                                <ul>
                                    <li>A primitive data type</li>
                                    <li>An immutable identifier used as a property key in objects.</li>
                                    <li>Each symbol is unique</li>
                                    <li>A bit like UUIDs/GUIDs, but built in to js.</li>
                                    <li><blockcode>const symbolVar = Symbol('description')</blockcode>, you don't use a new keyword, and the description does not effect it's uniqueness.</li>
                                    <li>To store a symbol in an Object <blockcode>
                                        const objName = {
                                            key1: 'value1',
                                            [Symbol('description')]: 'value2'
                                        }
                                    </blockcode> or <blockcode>
                                        const symbolVar = Symbol('description')
                                        const objName = {
                                            key1: 'value1',
                                            [symbolVar]: 'key2'
                                        }
                                    </blockcode> or (most common)<blockcode>
                                        const symbolVar = Symbol('description')
                                        const objName = {
                                            key1: 'value1',
                                        }
                                        objName[symbolVar] = 'key2'
                                    </blockcode></li>
                                    <li>You won't be able to see the symbol unless you specifically ask for the symbol like <blockcode>
                                        console.log(objName[symbolVar])
                                    </blockcode></li>
                                    <li>Used to add properties to objects without the risk of property name conflicts.</li>
                                    <li>Symbols are not 100% private.</li>
                                    <li>Misuse or overuse of symbols can lead to the confusion or coplexity in code maintenance.</li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>Map Object</span>
                                <ul>
                                    <li>Has nothing to do with the array map method.</li>
                                    <li>The map object holes key/value pairs just like a regular object.</li>
                                    <li class="sub-sub-list"><span>Map Object Benefits</span>
                                        <ul>
                                            <li>Use other data types as keys <blockcode>
                                                const objOne = { key1: "value1", key2: "value2" }

                                                const mapObj = new Map()

                                                mapObj.set(objOne, 10000)
                                            </blockcode> logs the map object, key as objOnes content and the value as 10000</li>
                                            <li>Iterate with a forEach <blockcode>
                                                const objOne = { key1: "value1", key2: "value2" }
                                                const objTwo = { key1: "value3", key2: "value4" }
                                                const objThree = { key1: "value5", key2: "value6" }

                                                const mapObj = new Map()

                                                mapObj.set(objOne, 10000)
                                                mapObj.set(objTwo, 10200)
                                                mapObj.set(objThree, 9800)

                                                mapObj.forEach((value, key)=>console.log(key.key1, value))
                                            </blockcode> would log value1 10000 value3 10200 value5 9800 </li>
                                            <li>Has a size property (similar to length property) <blockcode>
                                                console.log(mapObj.size)
                                            </blockcode> would log 3</li>
                                            <li>You can access an individual property using the get method <blockcode>
                                                console.log(mapObj.get(objOne))
                                            </blockcode> would log 10000</li>
                                            <li>To delete a property <blockcode>
                                                console.log(mapObj.delete(objOne))
                                            </blockcode> would log true and delete objOne</li>
                                            <li>The has method will check if a property exists <blockcode>
                                                console.log(mapObj.has(objThree))
                                            </blockcode> would log true.</li>
                                            <li>Insertion Order is fixed and guaranteed.</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>Set Object</span>
                                <ul>
                                    <li>A set object stores unique values as individual items, not key/value pairs. It's a bit like an array but with each it4em unique - no duplicates.</li>
                                    <li><blockcode>
                                        const duplicatesArr = ['value1', 'value2', 'value3', 'value1', 'value2']

                                        const noDuplicatesArr = new Set(duplicatesArr)

                                        console.log(noDuplicatesArr) 
                                    </blockcode> logs Set(3) {'value1', 'value2', 'value3'}</li>
                                    <li>You can use a forEach on a set. Not all array methods though. To use all array methods, you have to convert it back to an array.</li>
                                    <li>Insurtion order is maintained.</li>
                                    <li>You can use <blockcode>
                                        noDuplicatesArr.add('value4')
                                    </blockcode> to add to the Object.</li>
                                    <li>You can use <blockcode>
                                        noDuplicatesArr.delte('value4')
                                    </blockcode> to delet from the Object.</li>
                                    <li>You can use <blockcode>
                                        noDuplicatesArr.has('value4')
                                    </blockcode> to see if it exists in the Object.</li>
                                    <li>You can use <blockcode>
                                        noDuplicatesArr.clear()
                                    </blockcode> to remove everything from the Object.</li>
                                    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" target="_blank" alt="MDN Docs on the Set Object">Learn more about the set Object and it's other methods!</a></li>
                                    <li>Many of the methods do not have wide browser support.</li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>Closures</span>
                                <ul>
                                    <li>Helps you access variables defined within a funciton, outside of said funciton.</li>
                                    <li><blockcode>
                                        function outerFunction(param) {
                                            const outerVariable = 'I am from the outer function'
                                            function innerFunction() {
                                                console.log(outerVariable)
                                                console.log(param)
                                            }
                                            return innerFunction
                                        }
                                        
                                        const closure = outerFunction('I am an argument')
                                        
                                        closure()
                                    </blockcode> logs I am from the outer function I am an argument.</li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>IIFEs</span>
                                <ul>
                                    <li>Effectively self calling.</li>
                                    <li>To immediately run a function wrap the function in () and end it in ().</li>
                                    <li><blockcode>
                                        (function() {
                                            function stuff
                                        })()
                                    </blockcode></li>
                                    <li><blockcode>
                                        (async function(param) {
                                            function stuff
                                        })('param')
                                    </blockcode></li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>Recursion</span>
                                <ul>
                                    <li>Function calling itself</li>
                                    <li>Recursive Function</li>
                                    <li>To reverse a number <blockcode>
                                        function countdown(count) {
                                            console.log(count)
                                            if (count = 0) {
                                                return count
                                            }
                                            countdown(count - 1)
                                        }
                                        countdown(5)
                                    </blockcode> logs 5 4 3 2 1 0</li>
                                    <li>Unwind to return the final value.</li>
                                    <li>To reverse a string <blockcode>
                                        function reverseStr(str){
                                            if (str.length &lt;= 0){
                                                return str;
                                            } else {
                                                return reverseStr(str.slice(1)) + str.slice(0, 1);
                                            }
                                        }
                                    </blockcode></li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>Currying</span>
                                <ul>
                                    <li><blockcode>
                                        function functionName(param1){
                                            return function(param2){
                                                return function(param3){
                                                    return `${param1} ${param2} ${param3}`
                                                }
                                            }
                                        }

                                        const with1 = functionName(param1)
                                        const with2And1 = with1(param2)
                                        const with3And2And1 = with2And1(param3)

                                        console.log(with3And2And1)
                                    </blockcode> logs param1 param2 param3</li>
                                    <li><blockcode>
                                        function functionName(param1){
                                            return function(param2){
                                                return function(param3){
                                                    return `${param1} ${param2} ${param3}`
                                                }
                                            }
                                        }

                                        const with3And2And1 = with2And1(param1)(param2)(param3)

                                        console.log(with3And2And1)
                                    </blockcode> logs param1 param2 param3</li>
                                    <li>Written as an arrow function <blockcode>
                                        const functionName = param1 => param2 => param3 => `${param1} ${param2} ${param3}`
                                    </blockcode></li>
                                    <li class="sub-sub-list"><span>Why Curry a Function?</span>
                                        <ul>
                                            <li>Allows for partial application, which allows you to fix some arguments and defer the rest. This is useful when you repeatedly call a function with some of the same arguments.</li>
                                            <li><blockcode>
                                                const functionName = param1 => param2 => param3 => `${param1} ${param2} ${param3}`

                                                const onlyTwoParams = functionName(param1)(param2)

                                                const thirdParam1 = onlyTwoParams(param3)
                                                const thirdParam2 = onlyTwoParams(param4)
                                                const thirdParam3 = onlyTwoParams(param5)

                                                console.log(thirdParam1)
                                                console.log(thirdParam2)
                                                console.log(thirdParam3)
                                            </blockcode> logs param1 param2 param3 and param1 param2 param4 and param1 param2 param5</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>Throttling</span>
                                <ul>
                                    <li>Reduces Unecessary code execution.</li>
                                    <li>Ensures a function is called at most once in a specific period of time.</li>
                                    <li>When an event continuously triggers, throttling will call the function only at regular intervals, ignoring any additional triggers.</li>
                                    <li>Put a throttle on a resize event handler <blockcode>
                                        function handleResize(e){
                                            console.log('resize happened on event' + e)
                                        }

                                        function throttle(func, delay){
                                            let throttleTimeout = null
                                            return function() {
                                                if(!throttleTimeout){
                                                    func()
                                                    throttleTimeout = setTImeout(() => {
                                                        throttleTimeout = null
                                                    }, delay)
                                                }
                                            }
                                        }
                                        const throttleHandleResize = throttle(handleResize, 1000)
                                        window.addEventListener('resize', throttleHandleResize)
                                    </blockcode></li>
                                    <li>Add an event to the throttle <blockcode>
                                        function handleResize(e){
                                            console.log('resize happened on event: ' + e)
                                        }
                                        
                                        function throttle(func, delay) {
                                            let throttleTimeout = null
                                            return (...args)=> {
                                                if(!throttleTimeout) {
                                                    func(...args)
                                                    throttleTimeout = setTimeout(()=> {
                                                        throttleTimeout = null
                                                    }, delay)
                                                } 
                                            }
                                        }
                                        const throttledHandleResize = throttle(handleResize, 1000)
                                        window.addEventListener('resize', throttledHandleResize)
                                    </blockcode></li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>Debouncing</span>
                                <ul>
                                    <li>Reduces Unecessary code execution.</li>
                                    <li>Ensures a function is called only after a certain period has passsed since the last triggering event.</li>
                                    <li>When an event continuously fires, debouncing will delay the function call until after the event has stopped for a specified duration.</li>
                                    <li>Use debouncing with an input change event listener <blockcode>
                                        function debounce(func, delay) {
                                            let debounceTimer
                                            return (...args) => {
                                                clearTimeout(debounceTimer)
                                                debounceTimer = setTimeout(()=> {
                                                    func.apply(...args)
                                                }, delay)
                                            }
                                        }

                                        function handleInput(e) {
                                            console.log('Input detected from element with id ' + e.target.id)
                                        }
                                        
                                        document.getElementById('name-input').addEventListener('input', debounce(handleInput, 500))
                                    </blockcode></li>
                                </ul>
                            </li>
                            <li class="sub-list"><span>Generators</span>
                                <ul>
                                    <li class="sub-sub-list"><span>Common use cases</span>
                                        <ul>
                                            <li>Async operations</li>
                                            <li>Handling state</li>
                                            <li>Lazy evaluation</li>
                                        </ul>
                                    </li>
                                    <li>Using lazy evaluation <blockcode>
                                        const slidesArr = [
                                            "1", 
                                            "2", 
                                            "3", 
                                            "4", 
                                            "5"
                                        ]

                                        function* generator(arr) {
                                            for (const item of arr) {
                                                yield item
                                            }
                                        }

                                        const slideGenerator = generator(slidesArr)

                                        document.getElementById('nextSlideBtn').addEventListener('click', () => {
                                            const result = slideGenerator.next()
                                            if (!result.done) {
                                                console.log(result.value)   
                                            } else {
                                                console.log('That is the end!')
                                            }
                                        }) 
                                    </blockcode> logs 1 2 3 4 5 That is the end!</li>
                                    <li>The return keyword can stop a generator yeilding. <blockcode>
                                        const slidesArr = [
                                            "1",
                                            "2",
                                            "3",
                                            "MALFUNCTION",
                                            "4",
                                            "5"
                                        ]

                                        function* generator(arr) {
                                            for (const item of arr) {
                                                if (item === 'MALFUNCTION') {
                                                    return
                                                } else {
                                                    yield item
                                                }
                                            }
                                        }

                                        const slideGenerator = generator(slidesArr)

                                        document.getElementById('nextSlideBtn').addEventListener('click', () => {
                                            const result = slideGenerator.next()
                                            if (!result.done) {
                                                console.log(result.value)
                                            } else {
                                                console.log('That is the end!')
                                            }
                                        }) 
                                    </blockcode> logs 1 2 3 That is the end!</li>
                                </ul>
                            </li>
                            <li>To clear a form, use form reset <blockcode>form.reset()</blockcode></li>
                        </ul>
                    </div>
                    <div class="note-section resources" id="resources">
                        <h3 class="accordion-name" data-label="accordionName">Resources<span class="accordion-arrow"></span></h3>
                        <dl class="inner-accordion-content">
                            <dt>Create a UUID with a CDN</dt>
                                <dd>Current most common is Version 4 UUID, as it uses randomly generated characters.</dd>
                                <dd>One of the most popular tools for generating UUIDS is <a href="https://github.com/uuidjs/uuid#cdn-builds" target="_blank" alt="UUID CDN builds 
                                    Github documentation">UUID JS</a>. To copy this, go to the readme, select the CDN Builds link, copy the import, paste it in your project (test it). 
                                    Make sure your html has <blockcode>&lt;script type="module" src="jsFile"&gt;&lt;/script&gt;</blockcode> as the script tag. Return the uuidv4 function 
                                    (you can rename that) as a function <blockcode>uuidv4()</blockcode>.</dd>
                        </dl>
                    </div>
                    <div class="note-section definitions" id="definitions">
                        <h3 class="accordion-name" data-label="accordionName">Definitions<span class="accordion-arrow"></span></h3>
                        <dl class="inner-accordion-content">
                            <dt>DOM</dt>
                                <dd>Document Object Model</dd>
                                <dd>How you use JS to control websites.</dd>
                            <dt>Escape Character</dt>
                                <dd>A character that invokes an alternative interpretation on the following characters in a character sequence.</dd>
                            <dt>Local Dev Environment</dt>
                                <dd>A text editor is a tool to edit code on your computer.</dd>
                                <dd>Version control is a tool to keep changes updated on Github.</dd>
                                <dd class="sub-list"><span>Escape Characters List:</span>
                                    <ul>
                                        <li>\t = insert a tab in the text</li>
                                        <li>\b = insert a backspace in the text</li>
                                        <li>\n = insert a newline in the text</li>
                                        <li>\r = insert a carriage in the text</li>
                                        <li>\f = insert a form feed in the text</li>
                                        <li>\' = insert a single quote character in the text</li>
                                        <li>\" = insert a double quote character in the text</li>
                                        <li>\\ = insert a backslash character in the text</li>
                                    </ul>
                                </dd>
                            <dt>Data Type</dt>
                                <dd>defines the data type that a variable can store</dd>
                                <dd>Numbers, Strings, Boolean, Bigint, Undefined, Null, Symbol, Object</dd>
                            <dt>Method</dt>
                                <dd>Access and manipulate the data stored in an object.</dd>
                                <dd>written as <blockcode>method()</blockcode>.</dd>
                            <dt>createElement</dt>
                                <dd>A function that allows you to create an element.</dd>
                                <dd>A method that needs to be applied to the document object.</dd>
                                <dd><blockcode>document.createElement(elementType)</blockcode></dd>
                                <dd>Example: <blockcode>document.createElement("li")</blockcode></dd>
                            <dt>Template Strings</dt>
                                <dd><blockcode>`html stuff and also text and also ${variables}`</blockcode></dd>
                            <dt>Logical Not</dt>
                                <dd>Puting ! to mean not the following code.</dd>
                                <dt>Hoisting</dt>
                                <dd>Function declarations are moved to the top of their scope before code execution.</dd>
                            <dt>NaN</dt>
                                <dd>Not a Number</dd>
                            <dt>Web APIs</dt>
                                <dd>Provided by the browser.</dd>
                                <dd>Not part of the JS language.</dd>
                                <dd>Have functionality for DOM manipulation, data requests, timers (settimeout, setInterval), etc.</dd>
                            <dt>Inheritance</dt>
                                <dd>Inheritance is the mechanism by which objects inherit properties and methods from other objects.</dd>
                                <dt>DOM</dt>
                                <dd>Document Object Model</dd>
                                <dd>How you use JS to control websites.</dd>
                            <dt>Escape Character</dt>
                                <dd>A character that invokes an alternative interpretation on the following characters in a character sequence.</dd>
                            <dt>Local Dev Environment</dt>
                                <dd>A text editor is a tool to edit code on your computer.</dd>
                                <dd>Version control is a tool to keep changes updated on Github.</dd>
                                <dd class="sub-list"><span>Escape Characters List:</span>
                                    <ul>
                                        <li>\t = insert a tab in the text</li>
                                        <li>\b = insert a backspace in the text</li>
                                        <li>\n = insert a newline in the text</li>
                                        <li>\r = insert a carriage in the text</li>
                                        <li>\f = insert a form feed in the text</li>
                                        <li>\' = insert a single quote character in the text</li>
                                        <li>\" = insert a double quote character in the text</li>
                                        <li>\\ = insert a backslash character in the text</li>
                                    </ul>
                                </dd>
                            <dt>Data Type</dt>
                                <dd>defines the data type that a variable can store</dd>
                                <dd>Numbers, Strings, Boolean, Bigint, Undefined, Null, Symbol, Object</dd>
                            <dt>Method</dt>
                                <dd>Access and manipulate the data stored in an object.</dd>
                                <dd>written as <blockcode>method()</blockcode>.</dd>
                            <dt>createElement</dt>
                                <dd>A function that allows you to create an element.</dd>
                                <dd>A method that needs to be applied to the document object.</dd>
                                <dd><blockcode>document.createElement(elementType)</blockcode></dd>
                                <dd>Example: <blockcode>document.createElement("li")</blockcode></dd>
                            <dt>Template Strings</dt>
                                <dd><blockcode>`html stuff and also text and also ${variables}`</blockcode></dd>
                            <dt>Logical Not</dt>
                                <dd>Puting ! to mean not the following code.</dd>
                            <dt>Hoisting</dt>
                                <dd>Function declarations are moved to the top of their scope before code execution.</dd>
                            <dt>NaN</dt>
                                <dd>Not a Number</dd>
                            <dt>Web APIs</dt>
                                <dd>Provided by the browser.</dd>
                                <dd>Not part of the JS language.</dd>
                                <dd>Have functionality for DOM manipulation, data requests, timers (settimeout, setInterval), etc.</dd>
                            <dt>IIFE</dt>
                                <dd>Immediately Invoked Function Expressions</dd>
                            <dt>Currying</dt>
                                <dd>Transforming a function from one that takes multiple params into a sequence of nested functions, each taking a single param.</dd>
                            <dt>Generators</dt>
                                <dd>Special functions that can be paused and resumed allowing them to produce a sequence of values over time.</dd>
                            <dt>Declare</dt>
                                <dd>To create</dd>
                            <dt>To call an element</dt>
                                <dd>To take control of an element is to call the element.</dd>
                        </dl>
                    </div>
                    <div class="note-section questions" id="questions">
                        <h3 class="accordion-name" data-label="accordionName">Questions<span class="accordion-arrow"></span></h3>
                        <ul class="inner-accordion-content">
                            <li>Why does getElementByClassName return an array?</li>
                            <li>Is it better to use "" or '' in js?</li>
                            <li>What does i in the for loop mean?</li>
                            <li>Long but accurate function names, yes or no?</li>
                            <li>Is it bad practice to put a setTimeout method wihtin another setTimeout method?</li>
                            <li>Defining everything before using it or defining everything?<br />
                                <blockcode>
                                    let target = e.target.id
                                    console.log(target)
                                </blockcode> or
                                <blockcode>
                                    console.log(e.target.id)
                                </blockcode>
                            </li>
                            <li>How do you write a data attribute with multiple words in html and js?</li>
                            <li>If you store a function within a data obj and export the obj do you have to export the function too?</li>
                            <li>How does it know when it's a closure? Is there anything it needs? Is it just because it returns something?</li>
                        </ul>
                    </div>
                    <div class="note-section opinions" id="opinions">
                        <h3 class="accordion-name" data-label="accordionName">Opinions<span class="accordion-arrow"></span></h3>
                        <ul class="inner-accordion-content">
                            <li>You should separate functions from event listeners (call the function withing the event listener istead of writing it there).</li>
                            <li>JavaScript is a single-threaded, non-blocking language.</li>
                            <li>Name your function by thinking about what it is doing and what it's doing that to.</li>
                            <li>Use <blockCode>const hasElementDescription = true</blockCode> for naming a boolean.</li>
                            <li>It's best practice to not declare something unless you have to.</li>
                            <li>It's best practice to only use innerHTML when you have to. Use innerText instead.</li>
                            <li>Each function should do one thing.</li>
                            <li>When naming a boolean, it is common to start the name with is or has.</li>
                            <li>Use get at the begining of the name of a function when you will be returning something.</li>
                            <li>Use cabob-case when asigning the data attribute, you will need to make it camalCase in js. This is the best practice for multi-word attributes.</li>
                            <li>One event listener is DRYer than many, see if you can combine your event listeners, if it makes sense.</li>
                            <li>Use <blockcode>.innerHTML</blockcode> when you are adding tags/html and use <blockcode>.textContent</blockcode> when it's just text.</li>
                        </ul>
                    </div>
                </section>
            </div>
        </div>
    </main>
    <script type="module" src="/notes.js"></script>
</body>
</html>
